// The default approach to this problem has been to define a global bookstore
// like so:

var globalBookStore = __createBookStore();

// And to have all of our code operate on this global bookstore. There are some
// problems with this approach.

// Imagine that our deletion operation looks like this:

function statefulDeleteBook(book) {
    // ...delete book from globalBookStore...
    return book;
}

// What happens when I do this?

var book = {title: "Test"};
statefulDeleteBook(book);
statefulDeleteBook(book);

// The first time the book should be returned, and the second time I should get
// undefined. This is what's callend an *impure* function, or a function with
// *side-effects* -- even though the function is called with the same input, it
// returns *different* outputs each time. These kinds of functions are harder to
// debug, because it isn't apparent what the output will be when you call the
// function.

// Why does it matter?

// Imagine that I also have a function to check the store for a book, defined
// something like this:

function statefulCheckStore(query) {
    // Searches the `globalBookStore` for books matching `query`, and returns the
    // matching book if found; otherwise `undefined`.
}

// If I'm testing code that does a combination of `statefulCheckStore`ing and
// `statefulDeleteBook`ing, the order in which I call those functions will matter:

var book2 = {title: "Test"};
statefulCheckStore("Test");
statefulDeleteBook(book);
statefulCheckStore("Test");

// There's a cleaner way that we can define these operations in such a way that
// they do not depend on a piece of global state, and that's by parameterizing
// the `bookStore` itself. Here's an alternate implementation:

// Deletes a book from the input book store, and returns the deleted book if
// found; otherwise `undefined`.
function __deleteBook(bookStore, book) {
    return book;
}

// Searches the input bookStore for books matching `query`, and returns the
// matching book if found; otherwise `undefined`.
function __checkStore(bookStore, query) {
    // ...
}

// Structuring the code in this fashion means that we can test the actual
// functionality of the application with *mocked* state (the bookStore) -- this
// means that we can model our logic as *pure* functions. This means that given
// the same inputs, our functions always return the same output.

// Now, we can get the same behavior as before:

var store = __createBookStore();
var book3 = {title: "Test"};
__deleteBook(store, book);
__deleteBook(store, book);

// Or we do more interesting things
//var store2 = __createBookStore();
__deleteBook(__createBookStore(), book3); // should return the book
__deleteBook(__createBookStore(), book3); // exact same result as above
__deleteBook([], book3); // should return undefined, as there are no books in this store!
__deleteBook(moesBookStore, book3); // delete book from Moe's book store



var App = function() {
    var store = __createBookStore();
    return {
        deleteBook: function(book) {
            return __deleteBook(store, book);
        },
        checkStore: function(query) {
            return __checkStore(store, query);
        }
    };
};